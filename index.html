<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta autor="Ingrid" content="Dirgningrid" />

	<title>Dependency Injection and Dagger2</title>

	<link rel="stylesheet" href="reveal.js-3.5.0/css/reveal.css">
	<link rel="stylesheet" href="reveal.js-3.5.0/css/theme/solarized.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="reveal.js-3.5.0/lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js-3.5.0/css/print/pdf.css' : 'reveal.js-3.5.0/css/print/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<link rel="stylesheet" href="reveal.js-3.5.0/css/mystyle.css">
</head>
<body>
<div class="reveal">
	<div class="slides">
		<section>
			<h1>Dependency Injection</h1>
			<h2 class="fragment">e Dagger2</h2>
		</section>

		<section>
			<h2>Case study:</h2>
			<p>Supponiamo di sviluppare un'applicazione che gestisce eventi musicali</p>
			<p>la prima serata sarà dedicata ad un gruppo Rock</p>
			<br>
			<br>
			<p class="fragment fade-up">Come fareste?</p>

		</section>

		<section>
			<img  width="701" height="496" src="reveal.js-3.5.0/rsc/v1_uglyCode-2.jpg">
		</section>

		<section>
			<section>
				<h3>DepositoGiordani</h3>

					<pre style="width: auto"><code class="hljs" data-trim data-noescape>
public class DepositoGiordani {
 private Band band;

 public DepositoGiordani(){
  <span style="color: lawngreen">this.band = new Band();</span>
 }

 public void claimRockBand(){
  band.playSomething();
 }
}
					</code></pre>


				<div class="left">
					il DepositoGiordani crea la Band dal suo costruttore
				</div>
			</section>

			<section>
				<h3>Band</h3>

						<pre style="width: auto"><code class="hljs" data-trim data-noescape=>
public class Band {

 private RockerGuitarist guitarPlayer;
 private Singer singer;
 private RockerDrummer drummer;

public Band() {
 <span style="color: lawngreen">this.guitarPlayer = new RockerGuitarist();
 this.singer = new Singer();
 this.drummer = new RockerDrummer();</span>
 singer.setVoiceDecibel(70);
}

 public void playSomething(){
 ...
 }
}
						</code></pre>

				<div class="left">
					anche la Band dipende dai suoi musicisti, come i musicisti dagli strumenti
				</div>

			</section>
			<section>
				<h5>Diamo un'occhiata al Main</h5>
					<pre><code>
public class Main {

 public static void main(String[] args) {

  DepositoGiordani deposito = new DepositoGiordani();
  depositoGiordani.hiresRockBand();
 }
}
					</code></pre>
				<p class="fragment grow">Come fareste il test?</p>
			</section>
		</section>

		<section>
			<ul>
				<li>A causa delle dipendenze non è possibile isolare le classi
					<p class="fragment highlight-red">Non è testabile</p></li>

				<li>E se il prossimo concerto fosse di un gruppo Pop?
					<p class="fragment highlight-red">Non è riutilizzabile</p></li>
			</ul>
		</section>



		<section>
			<h5>come migliorare la situazione</h5>
			<img class="stretch" src="reveal.js-3.5.0/rsc/v2_abstractions.jpg">
		</section>
		<section>
			<p>Aumentando il livello di astrazione, e passando gli oggetti dall'esterno, adesso il DepositoGiordani può decidere se chiamare un gruppo Rock o un gruppo Pop</p>
		</section>



		<section>
			<section>
				<h4>Band</h4>
                    <pre><code data-trim data-noescape>
public class Band {
 private <span style="color: lawngreen">Guitarist guitarPlayer;</span>
 private Singer singer;
 private <span style="color: lawngreen">Drummer drummer;</span>

 public Band(Guitarist guitarist, Singer singer, Drummer drummer) {
  this.guitarPlayer = guitarist;
  this.singer = singer;
  this.drummer = drummer;
 }

 public void playSomething(boolean isRock) {
  ...
 }
}
					</code></pre>
				<p>passaggio a parametro di interfacce</p>
				<p>la creazione degli oggetti concreti è isolata</p>
			</section>

			<section>

				<p>Main_v1</p>
					<pre width="auto"><code style="font-size: medium" data-trim>
public class Main {
 public static void main(String[] args) {
  DepositoGiordani deposito = new DepositoGiordani();
  depositoGiordani.hiresRockBand();
 }
}
					</code></pre>


						<p>Main_v2</p>
                    <pre width="auto"><code style="font-size: medium" data-trim data-noescape>
public class Main {
 public static void main(String[] args) {
  Singer singer = new Singer();
  <span style="color: lawngreen">Drummer drummer = new PopDrummer(new Drums());</span>
  <span style="color: lawngreen">Guitarist guitarist = new PopGuitarist(new AcusticGuitar());</span>
  Band band = new Band(guitarist, singer, drummer);

  DepositoGiordani giordani = new DepositoGiordani(band);
  giordani.hiresPopBand();
 }
}
					</code></pre>
			</section>

			<section>
				<h4>Unit Test</h4>
					<pre><code data-trim data-noescape style="font-size: smaller">
public class BandTest {
 @Test
 public void testBandPlaySomething() throws Exception {
  RockerGuitarist guitarist = Mockito.mock(RockerGuitarist.class);
  RockerDrummer drummer = Mockito.mock(RockerDrummer.class);
  Singer singer = Mockito.mock(Singer.class);

  Band band = new Band(guitarist, singer, drummer);

  when(guitarist.playGuitar()).thenReturn("and I'm Slash, ");
  when(singer.singingSomething(true)).thenReturn("I'm Axl Rose ");
  when(drummer.letsGetBeat()).thenReturn("now, Let's Rock!");

  assertEquals("I'm Axl Rose and I'm Slash, now, Let's Rock!",
  band.playSomething(true));
 }
}
					</code></pre>
			</section>
		</section>

		<section>
			<ul>
				<p>PRO</p>
				<li>Grazie al disaccoppiamento il codice <span class="fragment highlight-blue">è riutilizzabile</span></li>
				<li>Ed <span class="fragment highlight-blue">è testabile</span></li>

				<p>CONTRO</p>
				<li>E' però aumentata la <span class="fragment highlight-red">complessità</span> nella creazione degli oggetti </li>
			</ul>
		</section>

		<section>
			<section>
				<h3>Dependency Injection</h3>
				<div class="row">
					<div class="left">
						<img width="600" height="480" src="reveal.js-3.5.0/rsc/what-is-dependency-injection.jpg" />
					</div>
					<p style="font-size: smaller">Il legame tra le classi è esterno: nessun oggetto istanzia un altro oggetto, questo compito è delegato ad una terza classe di configurazione che fornisce le istanze stesse</p>
				</div>
			</section>
		</section>

		<section>

			<section>
				<h2>Dagger2</h2>
				<p>crea la classe di configurazione per noi, l'importante è sapergli dire come fare, e quali oggetti vogliamo:</p>
				<ul>
					<li>@Module</li>
					<li>@Component</li>
					<li>@Inject</li>
				</ul>

			</section>
			<section>
				<h3>@Module</h3>
				<p>crea le dipendenze attraverso metodi pubblici che istanziano (@Provides) gli oggetti</p>
				<ul>
					<li>Factory Pattern: creazione degli oggetti con interfacce</li>
					<li>flessibilità</li>
					<li>dipendenza debole</li>
				</ul>
			</section>
			<section>
				<h3>@Component</h3>
				<p>Oggetto interfaccia che contiene le dipendenze, sarà lui a contattare il @Module, ottenendo i parametri di cui ha bisogno per fornire le dipendenze deboli</p>
				<div class="fragment fade-up">
				<h3>@Iject</h3>
				<p>Indica dove iniettare le dipendenze che Dagger ha creato</p>
				</div>
			</section>
		</section>
		<section>
			<section>
				<h4>@Module</h4>
							<pre><code data-trim>
@Module
public class RockBandModule {
  @Provides
  public Guitarist providesGuitarist(ElectricGuitar guitar){
   return new RockerGuitarist(guitar);
  }
  @Provides
  public Drummer providesDrummer(Drums drums){
   return new RockerDrummer(drums);

  @Provides
  public Singer providesSinger(){
   return new Singer();
  }
 }
}
							</code></pre>
			</section>
			<section>
@Module
public class RockInstrumentModule {

 @Provides
 public ElectricGuitar providesGuitar(){
  return new ElectricGuitar();
 }

 @Provides
 public Drums providesDrums(){
  return new Drums();
 }
}
			</section>
			<section>
				<h4>@Component e @Inject</h4>
						<pre><code data-trim>
@Component(modules = {RockBandModule.class,
		RockInstrumentModule.class} )
public interface RockBandComponent {

  Band injectBand();
  DepositoGiordani injectDeposito();
}
						</code></pre>
						<pre><code>
public class Band{
...
  @Inject
  public Band(Guitarist guitarist,
  		Singer singer,
		Drummer drummer) {
   this.guitarPlayer = guitarist;
   this.singer = singer;
   this.drummer = drummer;
  }
  ...
}
						</code></pre>
			</section>
		</section>

		<section>
			<section>
				<h4>Main</h4>
				<p>Dagger fornisce delle classi "helper" che espongono un builder statico, il quale si occupa della costruzione delle dipendenze a CompileTime</p>
				<pre><code data-trim data-noescape>
public class Main {
  public static void main(String[] args) {
   RockBandComponent rockComponent =
			<span style="color: lawngreen">DaggerRockBandComponent</span>
			.builder()
			.build();

   DepositoGiordani rock = rockComponent.injectDeposito();

   weWillRockYou = rock.hiresRockBand();
  ....
}}
				</code></pre>
			</section>
		</section>

		<section>
		<section>
			<h4>Unit Test</h4>
			<pre class="stretch"><code data-trim style="font-size: smaller">
@Module
public class BandMockModule {
  @Provides
  public Guitarist providesGuitarist(Guitar guitar){
   Guitarist guitarist = Mockito.mock(Guitarist.class);
    when(guitarist.playGuitar()).thenReturn("I'm Jhon Frusciante ");
    return guitarist;
 }
  @Provides
  public Singer providesSinger(){
   Singer singer = Mockito.mock(Singer.class);
    when(singer.singingSomething(true)).thenReturn("I'm Anthony Kiedis ");
    return singer;
 }
  @Provides
  public Drummer providesDrummer(Drums drums){
   Drummer drummer = Mockito.mock(Drummer.class);
    when(drummer.letsGetBeat()).thenReturn("now, let's funky rock pop or whatever!");
    return drummer;
 }
			</code></pre>

		</section>
		<section>
			<pre><code data-trim>
@Module
public class InstrumentMock {

  @Provides
  public Guitar providesGuitar(){
   return Mockito.mock(Guitar.class);
  }

  @Provides
  public Drums providesDrums(){
   return Mockito.mock(Drums.class);
  }
}
			</code></pre>
			<pre><code data-trim>
@Component(modules = {BandMockModule.class, InstrumentMock.class})
public interface BandComponentTest {
   Band injectBand();
}
			</code></pre>
			</section>
			<section>
			<pre><code data-trim>
public class RockBandTestDagger {
 @Test
 public void playSomething(){
  BandComponentTest component =
  		DaggerBandComponentTest
   			.builder()
			.build();

  Band band = component.injectBand();

  assertEquals("I'm Anthony Kiedis I'm John Frusciante
			now, let's funky rock pop and whatever!",
			band.playSomething(true));
 }
}
		</code></pre>
		</section>
		</section>

		<section>
			<h4>Thank you</h4>
			<ul style="list-style: none">
				<li><a href="https://github.com/Dirgningrid/dagger2inject" style="color: #068de9">https://github.com/Dirgningrid/dagger2inject</a> </li>

			</ul>
		</section>
	</div>
</div>

<script src="reveal.js-3.5.0/lib/js/head.min.js"></script>
<script src="reveal.js-3.5.0/js/reveal.js"></script>

<script>
	Reveal.initialize({
		controls: true,
		progress: true,
		history: false,
		center: true,

		transition: 'slide', // none/fade/slide/convex/concave/zoom

		// Optional reveal.js plugins

		dependencies: [
			{ src: 'reveal.js-3.5.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: 'reveal.js-3.5.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'reveal.js-3.5.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'reveal.js-3.5.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: 'reveal.js-3.5.0/plugin/zoom-js/zoom.js', async: true },
			{ src: 'reveal.js-3.5.0/plugin/notes/notes.js', async: true }
		]
	});
</script>
</body>
</html>
